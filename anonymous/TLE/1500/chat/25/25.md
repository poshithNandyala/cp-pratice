# Counting Ways to Select Balls from Bags

## Problem Restatement

We have:

  - **n bags** labeled from 0 to n-1.
  - Bag `i` contains `a[i]` balls (all balls are distinct within that bag).
  - We can **choose any number of balls**, but:
      - At most **one ball from each bag**.
      - We must respect the **original bag order** (no reordering bags).
  - We want to count the number of **non-empty selections** of balls.

We need the answer modulo **1e9+7** and in **O(n)** time.

-----

## Key Observations

### 1\. Choices for a Single Bag

For a bag with `a[i]` balls:

  - **Option 1**: Don’t take any ball → **1 way**.
  - **Option 2**: Take **exactly one** ball → **`a[i]` ways**.

Total possibilities for this bag:
$$1 + a[i]$$

-----

### 2\. Combining Choices Across Bags

Selections from different bags are **independent**:

  - Choice for bag 0 does not affect bag 1.
  - By the **Multiplication Principle**, total ways = product of choices.

For all bags:
$$\text{Total combinations (including empty)} = \prod_{i=0}^{n-1} (1 + a[i])$$

-----

### 3\. Removing the Empty Selection

The above includes the case where we take **no ball from any bag** (skip all), which is exactly **1 way**.

We want **non-empty** selections:
$$\text{Answer} = \left( \prod_{i=0}^{n-1} (1 + a[i]) \right) - 1$$

-----

## Example

Let `a = [1, 2]`:

  - Bag 0: 1 ball → choices = $1 + 1 = 2$ ways
  - Bag 1: 2 balls → choices = $1 + 2 = 3$ ways

Total combinations (including empty) = $2 \\times 3 = 6$.

These 6 are:

1.  (empty)
2.  {ball from bag 0}
3.  {ball from bag 1 \#1}
4.  {ball from bag 1 \#2}
5.  {bag 0’s ball, bag 1’s ball \#1}
6.  {bag 0’s ball, bag 1’s ball \#2}

Removing empty → $6 - 1 = 5$ ways.

-----

## Algorithm

1.  Initialize `prod = 1`.
2.  For each bag:
      - Compute `(a[i] + 1) % MOD`.
      - Multiply into `prod`.
3.  Subtract 1 (modulo MOD) to remove the empty selection.
4.  Return the result.

-----

## Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long MOD = 1e9+7;

long long solve(const vector<long long>& a) {
    long long prod = 1;
    for (long long v : a) {
        prod = prod * ((v % MOD + MOD) % MOD + 1) % MOD;
    }
    return (prod - 1 + MOD) % MOD; // subtract empty selection
}

int main() {
    int n;
    cin >> n;
    vector<long long> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    cout << solve(a) << "\n";
}
```

## Complexity

  - **Time:** $O(n)$ — one loop over the array.
  - **Memory:** $O(1)$ — only a running product variable.

## When to Use This Pattern

Use when:

  - You have multiple independent groups (bags, boxes, slots…).
  - For each group: “skip” or “choose one of many items”.
  - At most one item per group.
  - Counting all possible combinations (subtract empty if needed).

### Formula:

$$\text{Answer} = \left( \prod_{i=0}^{n-1} (1 + a[i]) \right) - 1$$