Here’s the problem in plain words, then the math, then the “why it works.”

# 1) What are we choosing?

* There are (n) people.
* Person (i) lives at position (x_i) on a line.
* Person (i) needs:

  * (t_i) minutes to get dressed,
  * plus (|x - x_i|) minutes to walk to a meeting point (x).
* If we pick a meeting point (x), the **finish time** (when everyone has arrived) is
  [
  T(x)=\max_{i}\big(t_i+\lvert x-x_i\rvert\big).
  ]
* Our goal: **choose (x) to make (T(x)) as small as possible.**

This is a **“minimize the worst-case (last finisher)”** problem, not a “sum” problem.

---

# 2) The answer (formula you can code directly)

Define two numbers from the input:
[
L=\min_i(x_i - t_i),\qquad R=\max_i(x_i + t_i).
]
Then:

* **Best meeting point**: (\displaystyle x_0=\frac{L+R}{2}) (a single real number; it’s unique).
* **Minimum finishing time**: (\displaystyle T^*=\frac{R-L}{2}).

That’s it! You can compute (L) and (R) in one pass and print ((L+R)/2).

---

# 3) Why this is true (layman intuition)

### Think in “deadlines”

Pick a candidate deadline (T) (“we want everyone to arrive by minute (T)”).
For person (i) to make it by time (T), the meeting point (x) must be close enough that:
[
t_i + |x - x_i| \le T \quad\Longleftrightarrow\quad |x - x_i| \le T - t_i.
]
This means (x) has to lie inside the **interval**
[
[x_i-(T-t_i),; x_i+(T-t_i)].
]
For **everyone** to make it by (T), **all these intervals must overlap** (have a common point).

* The **tightest** (smallest) (T) that allows overlap is when the “rightmost left endpoint” meets the “leftmost right endpoint.”
* Those extreme endpoints simplify to
  [
  \text{rightmost left endpoint}=\max_i{x_i-(T-t_i)}=L+T,\quad
  \text{leftmost right endpoint}=\min_i{x_i+(T-t_i)}=T+R - 2T = R-T.
  ]
  Overlap begins when (L+T \le R - T), i.e. (2T \ge R-L) → (T \ge (R-L)/2).
* At this minimal (T=T^*), the intervals **touch at exactly one point**:
  [
  x_0=\frac{L+R}{2}.
  ]
  So the best place is right where the two extremes balance.

### One-line geometric picture

Each person creates a “V” shape time curve (t_i + |x-x_i|). The maximum of these V’s is a roof. The roof is minimized where its **rising** and **falling** sides balance—exactly the midpoint between (L) and (R).

---

# 4) Why you can’t ignore (t_i)

If someone needs a long time to dress (big (t_i)), we should place the meeting point a bit **closer to them** to compensate, so they don’t become the last finisher.

Tiny example:

* Positions (x=[0,10]).
* Dress times (t=[100,0]).

  * Our formula: (L=\min(0-100,10-0)=-100), (R=\max(0+100,10+0)=100) → (x_0=( -100+100)/2=0).
  * If you **ignored** (t): you’d pick the middle of positions, (x=5), making the finish time (105) instead of the optimal (100).

You can ignore (t_i) **only** when all (t_i) are equal; then the best (x) is the midpoint of (\min x_i) and (\max x_i).

---

# 5) How to implement (per test case)

1. Initialize (L=+\infty), (R=-\infty).
2. For each (i):

   * update (L=\min(L,\ x_i - t_i)),
   * update (R=\max(R,\ x_i + t_i)).
3. Print ((L+R)/2) with enough precision (e.g., 1e-6).

**Time:** (O(n)). **Memory:** (O(1)).
Works with large inputs and meets the required accuracy.
